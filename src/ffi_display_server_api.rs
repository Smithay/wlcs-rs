/* automatically generated by rust-bindgen 0.64.0 */

//! FFI API for WLCS Display Server. Compositors that implement WLCS testing will use the
//! FFI wrappers that rely on the types defined here.
//!
//! Original C++ source:
//! [](https://github.com/MirServer/wlcs/blob/main/include/wlcs/display_server.h)

#![allow(non_camel_case_types, non_snake_case)]

use wayland_sys::{client::*, server as ssys};

use crate::{ffi_pointer_api::WlcsPointer, ffi_touch_api::WlcsTouch};

#[repr(C)]
#[derive(Debug, Copy, Clone)]
#[allow(missing_docs)]
pub struct WlcsExtensionDescriptor {
    #[doc = " Protocol name of extension (eg: wl_shell, xdg_shell, etc)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Maximum version of extension supported"]
    pub version: u32,
}
#[test]
fn bindgen_test_layout_WlcsExtensionDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<WlcsExtensionDescriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<WlcsExtensionDescriptor>(),
        16usize,
        concat!("Size of: ", stringify!(WlcsExtensionDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<WlcsExtensionDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(WlcsExtensionDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsExtensionDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsExtensionDescriptor),
            "::",
            stringify!(version)
        )
    );
}

unsafe impl Sync for WlcsExtensionDescriptor {}
unsafe impl Send for WlcsExtensionDescriptor {}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
#[allow(missing_docs)]
pub struct WlcsIntegrationDescriptor {
    #[doc = "< Version of the struct this instance provides"]
    pub version: u32,
    #[doc = "< Length of the supported_extensions array"]
    pub num_extensions: usize,
    #[doc = " Array of extension descriptions\n\n This must be an array of length num_extensions; that is, accesses from\n supported_extensions[0] to supported_extensions[num_extensions - 1]\n must be valid."]
    pub supported_extensions: *const WlcsExtensionDescriptor,
}
#[test]
fn bindgen_test_layout_WlcsIntegrationDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<WlcsIntegrationDescriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<WlcsIntegrationDescriptor>(),
        24usize,
        concat!("Size of: ", stringify!(WlcsIntegrationDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<WlcsIntegrationDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(WlcsIntegrationDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsIntegrationDescriptor),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_extensions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsIntegrationDescriptor),
            "::",
            stringify!(num_extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_extensions) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsIntegrationDescriptor),
            "::",
            stringify!(supported_extensions)
        )
    );
}

unsafe impl Sync for WlcsIntegrationDescriptor {}
unsafe impl Send for WlcsIntegrationDescriptor {}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
#[allow(missing_docs)]
pub struct WlcsDisplayServer {
    #[doc = "< Version of the struct this instance provides"]
    pub version: u32,
    #[doc = " Start the display server's mainloop.\n\n This should *not* block until the mainloop exits, which implies the mainloop\n will need to be run in a separate thread.\n\n This does not need to block until the display server is ready to process\n input, but the WlcsDisplayServer does need to be able to process other\n calls (notably create_client_socket) once this returns."]
    pub start: ::std::option::Option<unsafe extern "C" fn(server: *mut WlcsDisplayServer)>,
    #[doc = " Stop the display server's mainloop.\n\n In contrast to the start hook, this *should* block until the server's mainloop\n has been torn down, so that it does not persist into later tests."]
    pub stop: ::std::option::Option<unsafe extern "C" fn(server: *mut WlcsDisplayServer)>,
    #[doc = " Create a socket that can be connected to by wl_display_connect_fd\n\n \\return  A FD to a client Wayland socket. WLCS owns this fd, and will close\n          it as necessary."]
    pub create_client_socket: ::std::option::Option<
        unsafe extern "C" fn(server: *mut WlcsDisplayServer) -> ::std::os::raw::c_int,
    >,
    #[doc = " Position a window in the compositor coördinate space\n\n \\param client   the (wayland-client-side) wl_client which owns the\n                  surface\n \\param surface  the (wayland-client-side) wl_surface*\n \\param x         x coördinate (in compositor-space pixels) to move the\n                  left of the window to\n \\param y         y coördinate (in compositor-space pixels) to move the\n                  top of the window to"]
    pub position_window_absolute: ::std::option::Option<
        unsafe extern "C" fn(
            server: *mut WlcsDisplayServer,
            client: *mut wl_display,
            surface: *mut wl_proxy,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Create a fake pointer device"]
    pub create_pointer: ::std::option::Option<
        unsafe extern "C" fn(server: *mut WlcsDisplayServer) -> *mut WlcsPointer,
    >,
    #[doc = " Create a mock touch object"]
    pub create_touch: ::std::option::Option<
        unsafe extern "C" fn(server: *mut WlcsDisplayServer) -> *mut WlcsTouch,
    >,
    #[doc = " Describe the capabilities of this WlcsDisplayServer\n\n WLCS will use this description to skip tests that the display server\n is known to not support. For example, if the set of extensions\n described by the WlcsIntegrationDescriptor does not include \"xdg_shell\"\n then all XDG Shell tests will be skipped.\n\n Different WlcsDisplayServer instances may report different\n capabilities (for example, if command line options should influence\n the set of extensions exposed)."]
    pub get_descriptor: ::std::option::Option<
        unsafe extern "C" fn(server: *const WlcsDisplayServer) -> *const WlcsIntegrationDescriptor,
    >,
    #[doc = " Start the display server's event loop, blocking the calling thread.\n\n When started in this way WLCS will proxy all requests to this mainloop.\n All calls to WLCS interfaces will be dispatched from the\n wlcs_event_dispatcher loop, so implementations are required to drive\n this loop from their own.\n\n \\note    This is an optional interface. An implementation must provide at\n          least one of {start, start_on_this_thread}, but does not need to\n          provide both. If both are provided, start is preferred.\n\n \\param wlcs_event_dispatcher"]
    pub start_on_this_thread: ::std::option::Option<
        unsafe extern "C" fn(
            server: *mut WlcsDisplayServer,
            wlcs_event_dispatcher: *mut ssys::wl_event_loop,
        ),
    >,
}
#[test]
fn bindgen_test_layout_WlcsDisplayServer() {
    const UNINIT: ::std::mem::MaybeUninit<WlcsDisplayServer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<WlcsDisplayServer>(),
        72usize,
        concat!("Size of: ", stringify!(WlcsDisplayServer))
    );
    assert_eq!(
        ::std::mem::align_of::<WlcsDisplayServer>(),
        8usize,
        concat!("Alignment of ", stringify!(WlcsDisplayServer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_client_socket) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(create_client_socket)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position_window_absolute) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(position_window_absolute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_pointer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(create_pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_touch) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(create_touch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_descriptor) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(get_descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_on_this_thread) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsDisplayServer),
            "::",
            stringify!(start_on_this_thread)
        )
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
#[allow(missing_docs)]
pub struct WlcsServerIntegration {
    #[doc = "< Version of the struct this instance provides"]
    pub version: u32,
    #[doc = " Create a WlcsDisplayServer instance\n\n This can do any setup necessary, but should not start the compositor's\n mainloop.\n\n \\param argc  Command line argument count (after wlcs-specific options\n              have been stripped)\n \\param argv  Command line arguments (after wlcs-specific options have\n              been stripped)\n \\return"]
    pub create_server: ::std::option::Option<
        unsafe extern "C" fn(
            argc: ::std::os::raw::c_int,
            argv: *mut *const ::std::os::raw::c_char,
        ) -> *mut WlcsDisplayServer,
    >,
    pub destroy_server: ::std::option::Option<unsafe extern "C" fn(server: *mut WlcsDisplayServer)>,
}
#[test]
fn bindgen_test_layout_WlcsServerIntegration() {
    const UNINIT: ::std::mem::MaybeUninit<WlcsServerIntegration> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<WlcsServerIntegration>(),
        24usize,
        concat!("Size of: ", stringify!(WlcsServerIntegration))
    );
    assert_eq!(
        ::std::mem::align_of::<WlcsServerIntegration>(),
        8usize,
        concat!("Alignment of ", stringify!(WlcsServerIntegration))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsServerIntegration),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_server) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsServerIntegration),
            "::",
            stringify!(create_server)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy_server) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WlcsServerIntegration),
            "::",
            stringify!(destroy_server)
        )
    );
}
